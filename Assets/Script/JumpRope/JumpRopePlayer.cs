using Photon.Pun;
using System.Collections;
using UnityEngine;
public class JumpRopePlayer : MonoBehaviourPunCallbacks, IPunObservable
{
    private int winScore = 0;
    private int OpponentWinScore = 0;
    public float JumpeSpeed = 1000000f;
    private PhotonView pv;
    private Animator animator;
    private bool isJump = false;
    // Start is called before the first frame update
    void Start()
    {
        pv = GetComponent<PhotonView>();
        animator = GetComponent<Animator>();
        StartCoroutine(CheckFlow());
    }

    // Update is called once per frame
    void Update()
    {
        Jump();
        PlayerMove();
    }
    private void PlayerMove()
    {
        if (pv.IsMine)
        {
            float zPos = Input.GetAxis("Vertical");
            float xPos = Input.GetAxis("Horizontal");
            transform.Translate(new Vector3(zPos, 0f, xPos) * 2f * Time.deltaTime);

        }
    }
    //플레이어가 안넘어지게 rigidBody Freezen해둠 
    private void Jump()// 사용자가 점프키 누름
    {
        if (pv.IsMine)
        {
            if (Input.GetKeyDown(KeyCode.Space) && isJump == true)
            {
                AnimationSpeedChange();
                animator.SetBool("Jump", true);
                StartCoroutine(AddForce());
                StartCoroutine(StopAnimation("Jump", 1f));
            }
        }
    }
    private IEnumerator AddForce()
    {
        float speed = 0.4f;
        yield return new WaitForSeconds(0.3f);
        transform.Translate(Vector3.up * speed);
        yield return new WaitForSeconds(0.1f);
        transform.Translate(Vector3.up * speed);
        yield return new WaitForSeconds(0.1f);

    }
    private IEnumerator StopAnimation(string text, float time)//애니메이션을 몇초 지정후 false변경 raycast 오류 2번 재생
    {
        yield return new WaitForSeconds(time);
        animator.speed = 1.0f;
        animator.SetBool(text, false);
    }
    private IEnumerator CheckFlow()//캐릭터가 바닥에 닿았는지 체크
    {
        while (true)
        {
            RaycastHit hit;
            if (Physics.Raycast(transform.position, Vector3.down, out hit, 0.04f))
            {
                if (hit.collider.name == "Plane")
                {
                    isJump = true;
                }
                else
                {
                    isJump = false;
                }
            }
            yield return new WaitForSeconds(0.1f);
        }
    }
    IEnumerator saveCorutine = null;
    private void SaveCorutine(IEnumerator corutine)//코루틴을 저장하고 해당 코루틴 실행
    {
        saveCorutine = corutine;
        StartCoroutine(saveCorutine);
    }
    public void PlayerLose()//플레이 패배
    {
        if (pv.IsMine)
        {
            Debug.Log("PlayerLose");
            JumpRope.Instance.StopRotationRope();
            transform.position = JumpRopeSystem.Instance.SetStartPoint();
            pv.RPC("RpcPlayerWin", RpcTarget.OthersBuffered);
            OpponentWinScore++;
            JumpRope.Instance.ChangeText(JumpRope.Instance.texts[1], OpponentWinScore);
            JumpRope.Instance.RopeReSetting();
        }
        //줄멈추고 위치 초기화
        //플레이어 위치 초기화
        //상대에게 승리했다고 전달
        //상대점수 상승
        //UITEXT 변경
        //겜 원위치에서 재시작
    }
    [PunRPC]
    private void RpcPlayerWin()//받았을 경우 상대로부터 승리
    {
        Debug.Log("rpcWin");
        JumpRope.Instance.StopRotationRope();
        transform.position = JumpRopeSystem.Instance.SetStartPoint();
        winScore++;
        JumpRope.Instance.ChangeText(JumpRope.Instance.texts[0], winScore);
        JumpRope.Instance.RopeReSetting();
    }
    private void AnimationSpeedChange()
    {
        animator.speed = 1.3f;
    }




    /// <summary>
    /// //////////////////////////////////////////////////////////////////////////////////////////////
    /// </summary>
    //플레이 1이 플레이 2를 이겼다. 플레이 1은 승리표시하고 상대한테는 패배코드를 날린다.
    [PunRPC]
    private void Talk(int num)
    {

    }
    private int text = -1;
    //보내준 줄이랑 받는 줄의 수가 같아야함
    public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
    {
        if (stream.IsWriting)
        {
            stream.SendNext(0);
        }
        else
        {
            text = (int)stream.ReceiveNext();
        }

    }
}
